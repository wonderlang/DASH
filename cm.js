//STDLIB is called cm
//This will be one helluva challenge to read, I'm sure. Sorry!
//All cm functions are either unary or binary; no more, no less.
//Note that almost all of these functions work with the properties of the types.
//If you want to add other functions, be sure to at least *try* to notice some
//of the structures that I use (esp. for type checking/conversion).
//More info can be found on the Github wiki's page on cm functions.

cm={
  //input
  rl:x=>str(Exec('read x;echo $x',{stdio:[process.stdin]})),
  rf:x=>str(fs.readFileSync(x.body+'')+''),

  //output
  //Using the form and sform functions are important here
  eX:x=>(expr=tru(x).body,x),
  os:x=>(process.stdout.write(form(x).replace(/\x1b\[\d+m/g,'')),x),
  ol:x=>(process.stdout.write(sform(x)),x),
  oN:x=>(process.stdout.write(sform(x)+'\n'),x),
  wf:(x,y)=>(fs.writeFileSync(''+x.body,sform(y)),y),

  //num
  //Use num(x.body).body for converting to number
  num:x=>num(x.body),
  //charcode
  tc:x=>ls(x.body.map(a=>num(a.codePointAt()))),
  fc:x=>str(
    x.type=='ls'?
      x.body.map(a=>cm.fc(I(a)).body).join('')
    :String.fromCodePoint(0|num(x.body).body)
  ),
  //base
  hx:x=>str(d(''+num(x.body).body).toHexadecimal()),
  bn:x=>str(d(''+num(x.body).body).toBinary()),
  ot:x=>str(d(''+num(x.body).body).toOctal()),
  //precision and rounding
  E:x=>(dp=0|num(x.body).body,x),
  fix:(x,y)=>str(d(''+num(x.body).body).toFixed(0|num(y.body).body)),
  rnd:x=>num(0|num(x.body).body?d.random(0|num(x.body).body):''+0|d.random()*2),
  flr:x=>num(d.floor(''+num(x.body).body)),
  trunc:x=>num(d.trunc(''+num(x.body).body)),
  round:x=>num(d.round(''+num(x.body).body)),
  ceil:x=>num(d.ceil(''+num(x.body).body)),
  //sign
  sign:x=>num(d.sign(''+num(x.body).body)),
  abs:x=>num(d.abs(''+num(x.body).body)),
  neg:x=>num(d(num(x.body).body+'').neg()),
  //number comparison
  cmp:(x,y)=>num(d(''+num(x.body).body).cmp(''+num(y.body).body)),
  max:x=>num(d.max(...x.body.map(a=>''+num(a.body).body).value())),
  min:x=>num(d.min(...x.body.map(a=>''+num(a.body).body).value())),
  //arithmetic
  add:(x,y)=>num(d.add(''+num(x.body).body,''+num(y.body).body)),
  sum:x=>num(x.body.map(a=>x.body.charAt?str(a):a).reduce((a,b)=>d.add(a,''+num(b.body).body),0)),
  sub:(x,y)=>num(d.sub(''+num(x.body).body,''+num(y.body).body)),
  mul:(x,y)=>num(d.mul(''+num(x.body).body,''+num(y.body).body)),
  prod:x=>num(x.body.map(a=>x.body.charAt?str(a):a).reduce((a,b)=>d.mul(a,''+num(b.body).body),1)),
  div:(x,y)=>num(d.div(''+num(x.body).body,''+num(y.body).body)),
  mod:(x,y)=>num(d.mod(''+num(x.body).body,''+num(y.body).body)),
  pow:(x,y)=>
    (X=d.pow(''+num(x.body).body,''+num(y.body).body))+''=='NaN'?
      tru(0)
    :num(X),
  exp:x=>num(d.exp(''+num(x.body).body)),
  hypot:(x,y)=>num(d.hypot(''+num(x.body).body,''+num(y.body).body)),
  //factorization
  fac:x=>ls(
    _.range(1,(X=Math.abs(0|num(x.body).body))/2+1|0)
      .filter(a=>!(X%a))
      .map(num)
      .concat(num(X))
  ),
  pfac:x=>(x=num(Math.abs(+num(x.body).body)),cm.flat(ls(
    +num(x.body).body<2?
      []
    :cm.pr(x).body?
      [x]
    :[num(X=cm.fac(x).body.get(1).body),cm.pfac(num(x.body/X))]
  ))),
  pr:x=>(x=num(Math.abs(+num(x.body).body)),tru(
    +num(x.body).body>1&&
      !cm.fac(x).body.find(a=>
        +a.body>1&&+a.body<+num(x.body).body
      )
  )),
  gcd:(x,y)=>num((
    g=(m,n)=>m>n?g(m-n,n):m<n?g(m,n-m):m
  )(Math.abs(0|x.body),Math.abs(0|y.body))),
  lcm:(x,y)=>(X=0|x.body,Y=0|y.body,X*Y/cm.gcd(x,y)),
  //logarithms
  log:(x,y)=>num(d.log(''+num(x.body).body,''+num(y.body).body)),
  ln:x=>num(d.ln(''+num(x.body).body)),
  ltn:x=>num(d.log10(''+num(x.body).body)),
  //trig
  sin:x=>num(d.sin(''+num(x.body).body)),
  sinh:x=>num(d.sinh(''+num(x.body).body)),
  asin:x=>num(d.asin(''+num(x.body).body)),
  asinh:x=>num(d.asinh(''+num(x.body).body)),
  cos:x=>num(d.cos(''+num(x.body).body)),
  cosh:(x,y)=>num(d.cosh(''+num(x.body).body)),
  acos:x=>num(d.acos(''+num(x.body).body)),
  acosh:x=>num(d.acosh(''+num(x.body).body)),
  tan:x=>num(d.tan(''+num(x.body).body)),
  tanh:x=>num(d.tanh(''+num(x.body).body)),
  atan:x=>num(d.atan(''+num(x.body).body)),
  atanh:x=>num(d.atanh(''+num(x.body).body)),
  atant:(x,y)=>num(d.atan2(''+num(x.body).body,''+num(y.body).body)),

  //bool
  //The tru function is important here
  bool:x=>tru(x),
  tru:x=>tru(tru(x).body||x.type!='bool'),
  //comparisons
  eq:(x,y)=>tru(
    form(
      x.type=='obj'?obj(x.body.sort().toObject()):x
    )==form(
      y.type=='obj'?obj(y.body.sort().toObject()):y
    )||
      (x.body.charAt&&y.body.charAt&&
        ''+num(x.body).body==''+num(y.body).body
      )
  ),
  Eq:(x,y)=>tru(cm.eq(x,y).body&&x.type==y.type),
  gt:(x,y)=>tru(+d(''+num(x.body).body).cmp(''+num(y.body).body)==1),
  lt:(x,y)=>tru(+d(''+num(x.body).body).cmp(''+num(y.body).body)==-1),
  lteq:(x,y)=>tru(+d(''+num(x.body).body).lte(''+num(y.body).body)),
  gteq:(x,y)=>tru(+d(''+num(x.body).body).gte(''+num(y.body).body)),
  //boolean logic
  and:(x,y)=>tru(tru(x).body&&tru(y).body),
  or:(x,y)=>tru(tru(x).body||tru(y).body),
  xor:(x,y)=>tru(+(tru(x).body!=tru(y).body)),
  not:x=>tru(+!tru(x).body),

  //map family
  //y.body.charAt?str(a):a converts any iterable type to a list
  map:(x,y)=>ls(y.body.map(a=>I(app(x,y.body.charAt?str(a):a)))),
  fold:(x,y)=>y.body.reduce((a,b)=>I(app(app(x.body.get(0),b),y.body.charAt?str(a):a)),x.body.get(1)),
  foldr:(x,y)=>y.body.reduceRight((a,b)=>I(app(app(x.body.get(0),b),y.body.charAt?str(a):a)),x.body.get(1)),
  tkwl:(x,y)=>ls(y.body.takeWhile(a=>tru(I(app(x,y.body.charAt?str(a):a))).body)),
  drwl:(x,y)=>ls(y.body.dropWhile(a=>tru(I(app(x,y.body.charAt?str(a):a))).body)),
  fltr:(x,y)=>ls(y.body.filter(a=>tru(I(app(x,y.body.charAt?str(a):a))).body)),
  find:(x,y)=>y.body.find(a=>tru(I(app(x,y.body.charAt?str(a):a))).body),
  findi:(x,y)=>y.body.map((a,b)=>tru(I(app(x,y.body.charAt?str(a):a))).body?num(b):0).find(a=>a)||tru(0),
  every:(x,y)=>tru(y.body.every(a=>tru(I(app(x,y.body.charAt?str(a):a))).body)),
  some:(x,y)=>tru(y.body.some(a=>tru(I(app(x,y.body.charAt?str(a):a))).body)),

  //array getting, setting, manipulating
  tK:x=>(tk=0|num(x.body).body,x),
  len:x=>num(len(x)),
  tk:(x,y)=>ls(y.body.take(0|num(x.body).body).map(a=>a.charAt?str(a):a)),
  dp:(x,y)=>ls(y.body.drop(0|num(x.body).body).map(a=>a.charAt?str(a):a)),
  get:(x,y)=>I((
    y.type=='pm'?
      app(y,x)
    :y.type=='obj'?
      y.body.get(''+x.body)
    :y.body.map(a=>a.charAt?str(a):a).get(0|d.mod(0|num(x.body).body,len(y)))
  )||tru(0)),
  iget:(x,y)=>I((
    y.type=='obj'?
      y.body.get(''+x.body)
    :y.body.map(a=>a.charAt?str(a):a).get(0|num(x.body).body)
  )||tru(0)),
  set:(x,y)=>
    y.type=='pm'?
      pm(
        y.body.find(a=>a[0]!='@'&&cm.eq(x.body.get(0),a[0]).body)?
          y.body.map(a=>a[0]!='@'&&cm.eq(x.body.get(0),a[0]).body?[x.body.get(0),x.body.get(1)]:a)
        :y.body.concat([[x.body.get(0),x.body.get(1)]])
      )
    :y.type=='obj'?
      (X={},X[x.body.get(0).body]=x.body.get(1),obj(y.body.assign(X)))
    :ls(y.body.map(a=>y.type=='str'?str(a):a).map((a,b)=>
      b==''+d.mod(''+x.body.get(0).body,len(y))?
        x.body.get(1)
      :a)
    ),
  iset:(x,y)=>
    y.type=='pm'?
      pm(y.body.concat([[x.body.get(0),x.body.get(1)]]))
    :y.type=='obj'?
      (X={},X[x.body.get(0).body]=x.body.get(1),obj(y.body.assign(X)))
    :ls(y.body.map(a=>y.type=='str'?str(a):a).map((a,b)=>
      b==''+x.body.get(0).body?
        x.body.get(1)
      :a)
    ),
  ins:(x,y)=>
    y.type=='obj'||y.type=='pm'?
      cm.set(x,y)
    :(
      Y=y.body.map(a=>y.type=='str'?str(a):a),
      ls(Y.take(d.mod(0|x.body.get(0).body,len(y))).concat(x.body.get(1),
      Y.last(len(y)-d.mod(''+x.body.get(0).body,len(y)))))
    ),
  iins:(x,y)=>
    y.type=='obj'||y.type=='pm'?
      cm.set(x,y)
    :(
      Y=y.body.map(a=>y.type=='str'?str(a):a),
      ls(Y.take(0|x.body.get(0).body).concat(x.body.get(1),
      Y.drop(0|x.body.get(0).body)))
    ),
  con:(x,y)=>
    x.type!='ls'?
      x.type!='obj'?
        str(sform(x)+sform(y))
      :obj(Object.assign(x.body.value(),y.body.map(a=>y.body.charAt?str(a):a).value()))
    :cm.flat(ls([x,y])),
  iO:(x,y)=>ls(y.body.map((a,b)=>cm.eq(y.body.charAt?str(a):a,x).body?num(b):0).filter(a=>a)),
  fiO:(x,y)=>y.body.map((a,b)=>cm.eq(y.body.charAt?str(a):a,x).body?num(b):0).find(a=>a)||tru(0),
  rev:x=>ls(x.body.map(a=>x.body.charAt?str(a):a).reverse()),
  shuf:x=>ls((x.body.charAt?x.body.map(str):x.body).shuffle()),
  sort:(x,y)=>ls(y.body.sortBy(a=>num(I(app(x,y.body.charAt?str(a):a)).body).body)),

  //generating sequences
  rng:(x,y)=>(
    [X,Y]=[+x.body,+y.body],
    ls(l.generate(a=>num(d.add(a,''+num(x.body).body))).take(Y-X))
  ),
  gen:x=>ls(l.generate(a=>app(x,num(a)),1/0)),
  genc:(x,y)=>ls(l.generate(a=>[...Array(a)].reduce(i=>I(app(x,i)),y),1/0)),
  rpt:(x,y)=>ls(l.repeat(y,1/0).take(num(x.body).body)),
  cyc:x=>ls(l.generate(a=>cm.get(num(a),x),1/0)),

  //combinatorics
  perm:(x,y)=>ls(C.permutation(
    y.body.map(a=>y.body.charAt?str(a):a).value(),
    0|num(x.body).body
  ).map(ls)),
  comb:(x,y)=>ls(C.combination(
    y.body.map(a=>y.body.charAt?str(a):a).value(),
    0|num(x.body).body
  ).map(ls)),
  pows:x=>ls(C.power(x.body.map(a=>x.body.charAt?str(a):a).value()).map(ls)),
  cprd:x=>ls(C.cartesianProduct(...
    x.body.map(a=>a.body.map(b=>a.body.charAt?str(b):b).value()).value()
  ).map(ls)),
  base:(x,y)=>ls(C.baseN(
    y.body.map(a=>y.body.charAt?str(a):a).value(),
    0|num(x.body).body
  ).map(ls)),

  //set operations
  unq:x=>ls(
    x.body
      .map(i=>i.charAt?str(i):i)
      .uniq(a=>form(a.type=='obj'?obj(a.body.sort().toObject()):a))
  ),
  inx:(x,y)=>(
    [X,Y]=[
      x.body.map(a=>x.body.charAt?str(a):a),
      y.body.map(a=>y.body.charAt?str(a):a)
    ],
    ls(X.filter(a=>Y.find(b=>cm.eq(a,b).body)))
  ),
  uni:(x,y)=>cm.unq(cm.flat(ls([
    ls(x.body.map(a=>a.charAt?str(a):a)),
    ls(y.body.map(a=>a.charAt?str(a):a))
  ]))),
  dff:(x,y)=>(
    [X,Y]=[
      x.body.map(a=>x.body.charAt?str(a):a),
      y.body.map(a=>y.body.charAt?str(a):a)
    ],
    A=X.concat(Y),
    ls(X.filter(a=>
      !Y.find(b=>cm.eq(a,b).body)
    ))
  ),

  //nested lists
  chunk:(x,y)=>ls(
    y.body.charAt?
      y.body.chunk(0|num(x.body).body).map(a=>str(a.join``))
    :y.body.chunk(0|num(x.body).body).map(ls)
  ),
  tsp:x=>ls(
    x.body.first().body.map((a,i)=>ls(
        x.body.map(b=>b.body.get(i)).map(b=>b?b.charAt?str(b):b:tru(0))
    ))
  ),
  flat:x=>ls(
    x.body.map(a=>x.body.charAt?str(a):a.type=='ls'?a.body:a).flatten()
  ),
  zip:(x,y)=>cm.map(I(app(fn('sS'),x)),cm.tsp(y)),
  cns:(x,y)=>ls(
    y.body.map(a=>y.body.charAt?str(a):a)
      .consecutive(0|num(x.body).body)
      .map(ls)
  ),

  //obj
  ind:x=>cm.tsp(I(ls(
    x.type=='obj'?
      [ls(x.body.keys().map(a=>str(''+a))),ls(x.body.values())]
    :[cm.rng(num(0),num(len(x))),x]
  ))),
  key:x=>cm.tsp(cm.ind(x)).body.first(),
  val:x=>cm.tsp(cm.ind(x)).body.last(),
  pk:(x,y)=>obj(y.body.pick(x.body.map(a=>a.body).value())),
  om:(x,y)=>obj(y.body.omit(x.body.map(a=>a.body).value())),
  obj:x=>obj(
    x.body.map(a=>[
      sform((A=a.body.get(0)).charAt?str(A):A),
      (B=a.body.get(1)).charAt?str(B):B
    ]).toObject()
  ),
  obl:x=>cm.obj(cm.tsp(ls([cm.key(x),x]))),

  //str
  str:x=>str(sform(x)),
  src:x=>str(form(x).replace(/\x1b\[\d+m/g,'')),
  join:(x,y)=>str(y.body.map(sform).join(sform(x))),
  lc:x=>str((''+x.body).toLowerCase()),
  uc:x=>str((''+x.body).toUpperCase()),

  //rgx
  R:(x,y)=>({type:'rgx',body:XRE(''+x.body,''+y.body)}),
  //matching
  mstr:(x,y)=>obj(
    l(Object.assign({},XRE.match(''+y.body,rgx(x))||[]))
      .map((a,b)=>[b,str(a)])
      .toObject()
  ),
  xstr:(x,y)=>obj(
    l(Object.assign({},XRE.exec(''+y.body,rgx(x))||[]))
      .map((a,b)=>[b,(a.toFixed?num:str)(a)])
      .toObject()
  ),
  sstr:(x,y)=>num((XRE.exec(''+y.body,rgx(x))||[]).index||tru(0)),
  gstr:(x,y)=>ls(y.body.split('\n').filter(a=>XRE.match(a,rgx(x))).map(str)),
  Gstr:(x,y)=>ls(y.body.split('\n').reject(a=>XRE.match(a,rgx(x))).map(str)),
  //replacing
  split:(x,y)=>ls(XRE.split(''+y.body,rgx(x)).map(str)),
  rstr:(x,y)=>str(
    XRE.replace(
      y.body+'',
      rgx(x.body.get(0)),
      (x.body.get(1)||str('')).body.charAt
      &&(x.body.get(1)||str('')).type!='fn'
      &&(x.body.get(1)||str('')).type!='pt'?
        ''+(x.body.get(1)||str('')).body
      :(a,...b)=>sform(I(app(
        x.body.get(1),
        I([str(a)].concat(b.slice(0,-2).map(i=>str(i||''))))
      )))
    )
  ),
  Rstr:(x,y)=>
    tru(cm.mstr(x.body.get(0),y)).body?
      cm.Rstr(x,cm.rstr(x,y))
    :y,

  //flow
  type:x=>str(x.type),
  var:(x,y)=>vs[x.body]?vs[x.body]:(vs[x.body]=y),
  while:(x,y)=>(
    [X,Y]=[x.body.get(0),x.body.get(1)],
    tru(I(app(X,y))).body?cm.while(x,I(app(Y,y))):y
  ),
  pkg:x=>pkg(''+x.body),
  eval:x=>parser.parse(''+x.body),
  sh:x=>str(Exec(''+x.body)+''),
  js:x=>str(eval(''+x.body)+''),
  sleep:x=>(slp.usleep(0|num(x.body).body),x),
  exit:x=>{process.exit()},
  //combinators/applications
  S:(x,y)=>I(app(x,y)),
  K:(x,y)=>x,
  I:x=>x,
  tt:x=>(x.rev=x.rev!=[]._?!x.rev:1,x),
  ss:(x,y)=>x.body.reduceRight((a,b)=>I(app(b,a)),y),
  sS:(x,y)=>y.body.reduce((a,b)=>I(app(a,b)),x)
};

//cm aliases
[
  ['+','add'],
  ['|^','ceil'],
  ['/','div'],
  ['e^','exp'],
  ['|_','flr'],
  ['%','mod'],
  ['*','mul'],
  ['^','pow'],
  ['|=','round'],
  ['+-','sign'],
  ['-','sub'],
  ['|-','trunc'],
  ['=','eq'],
  ['==','Eq'],
  ['>','gt'],
  ['<','lt'],
  ['>=','gteq'],
  ['<=','lteq'],
  ['_','neg'],
  ['->','map'],
  ['+>','fold'],
  ['<+','foldr'],
  ['_>','tkwl'],
  ['~>','drwl'],
  ['!>','fltr'],
  [':>','find'],
  [',>','findi'],
  ['*>','every'],
  ['/>','some'],
  [':','get'],
  [':^','iget'],
  [':=','set'],
  [':=^','iset'],
  [':+','ins'],
  [':+^','iins'],
  ['><','join'],
  ['<>','split'],
  ['++','con'],
  ['$$','eval'],
  ['%%','sleep'],
  ['<|>','chunk'],
  ['&','and'],
  ['|','or'],
  ['$','xor'],
  ['!','not'],
  ["'",'tsp'],
  [',','ind']
].map(a=>cm[a[0]]=cm[a[1]])
